# C++ 笔记

# 第3章 函数
## 3.4 函数重载
定义：两个以上的函数，具有相同的函数名，但是形参的个数或者类型不同，编译器根据实参和形参的类型及个数的最佳匹配，自动确定调用哪一个函数，这就是函数重载。  

## 3.5 C++系统函数
[标准C++函数原型、头文件和用法](https://en.cppreference.com/w/)  

# 第4章 类与对象
## 4.1 特点
### 4.1.1 抽象
抽象：数据抽象和行为抽象  
数据抽象：某类对象的属性或状态  
eg: int hour, int minute, int second  
行为抽象（或功能抽象、代码抽象）  
showTime(), setTime()  

### 4.1.2 封装  

### 4.1.3 继承

### 4.1.4 多态
多态性可通过强制多态、重载多态、类型参数化多态、包含多态4种形式实现  

## 4.2 类与对象
内联函数包含：
隐式声明：将函数体直接放在类体中。
显式声明：采用关键字inline，即在函数体实现时，在函数返回值类型前加上inline，类定义中不加入函数体。

## 4.3 构造函数与析构函数
### 4.3.1 构造函数
如果类中没有写构造函数，编译器会自动生成一个隐含的默认构造函数，该构造函数的参数列表和函数体皆为空。  

### 4.3.2 复制构造函数
隐含的复制构造函数的功能：把初始值对象的每个数据成员的值都复制到新建的对象中。  
```
class 类名
{
public:
    类名(形参表);
    类名(类名 &对象名);
    ...
};
类名::类名(类名 &对象名)
{
    函数体
}
```
普通构造函数是在对象创建时被调用，而复制构造函数在以下3种情况下都会被调用：  
1. 当用类的一个对象去初始化该类的另一个对象时；
2. 如果函数的形参是类的对象，调用函数时，进行形参和实参结合时；
3. 如果函数的返回值是类的对象，函数执行完成返回调用者时。

### 4.3.3 析构函数
析构函数不接收任何参数，但可以是虚函数。  
如果不进行显式说明，系统也会生成一个函数体为空的隐含析构函数。  

## 4.4 类的组合
当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建。  
在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化。  
析构函数的调用执行顺序与构造函数刚好相反。  

## 4.5 UML

## 4.6 结构体和联合体
### 4.6.1 结构体
struct  
结构体和类的唯一区别在于：结构体和类具有不同的默认访问控制属性。类中，未指定的为private；结构体中，未指定的为public。  
c++中存在是为了保持和C程序兼容。  
### 4.6.2 联合体
union  
联合体是一种特殊形态的类，它可以有自己的数据成员和函数成员，可以有自己的构造函数和析构函数，可以控制访问权限。与结构体一样，联合体也是从C语言继承而来的，因此它的默认访问控制属性也是公共类型的。  
联合体的全部数据成员共享同一组内存单元。因此，联合体变量中的成员同时至少只有一个是有意义的。联合体有下面一些限制：  
1. 联合体的各个对象成员，不能有自定义的构造函数、自定义的析构函数和重载的复制赋值运算符，不仅联合体的对象成员不能有这些函数，这些对象成员的对象成员也不能有，以次类推。  
2. 联合体不能继承，因而也不支持包含多态。  

一般只用联合体来存储一些公有的数据，而不为它定义函数成员。  
联合体也可以不声明名称，称为无名联合体。  

# 第5章 数据的共享与保护
## 5.2 对象的生存期
### 5.2.1 静态生存期
如果对象的生存期与程序的运行期相同，则称它具有静态生存期。  
局部作用域中静态变量的特点是，它并不会随着每次函数调用而产生一个副本，也不会随着函数返回而失效。  
### 5.2.2 动态生存期
局部作用域中声明的具有动态生存期的对象，习惯上也称为局部生存期对象。  
局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时。  
类的成员对象也有各自的生存期。不用static修饰的成员对象，其生存期都与它们所属对象的生存期保持一致。  

## 5.3 类的静态成员
### 5.3.1 静态数据成员
类属性是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的。  
静态数据成员具有静态生存期。一般用法：“类名::标识符”。  
在类的定义中仅仅对静态数据成员进行引用性声明，必须在命名空间作用域的某个地方使用类名限定定义性声明，这时也可以进行初始化。（之所以类的静态数据成员需要在类定义之外再加以定义，是因为需要以这种方式专门为它们分配空间。非静态数据成员无须以次方式定义，因为它们的空间是与它们所属对象的空间同时分配的。）  
### 5.3.2 静态函数成员
虽然静态成员函数可以通过类名和对象名两种方式调用，但一般习惯于通过类名调用。因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关系。  
静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名。  

## 5.4 类的友元
友元关系提供了不同类和对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。  
友元关系就是一个类主动声明哪些其他类或函数是它的朋友，进而给它们提供对本类的访问特许。  
也就是说，通过友元关系，一个普通函数或者类的成员函数可以访问封装于另一个类中的数据。  
### 5.4.1 友元函数
友元函数是类中用关键字`friend`修饰的非成员函数。  
友元函数可以是一个普通的函数，也可以是其他类的成员函数。虽然它不是本类的成员函数，但是在它的函数体中可以通过对象名访问本类的私有和保护成员。  
### 5.4.2 友元类
若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护对象。
```
class B
{
    ...               //B类的成员声明
    friend class A    //声明A为B的友元类
    ...
};
```
注意：  
1. 友元关系是不能传递的。
2. 友元关系是单向的。
3. 友元关系是不能被继承的。

## 5.5 共享数据的保护  
### 5.5.1 常对象
常对象：它的数据成员值在对象的整个生存期间内不能被改变。  
也就是说，常对象必须进行初始化，而且不能被更新。  
`const 类型说明符 对象名;`  
在声明常对象时，把const关键字放在类型名后面也是允许的，不过人们更习惯于把const写在前面。  
### 5.5.2 用const修饰的类成员
格式如下：  
`类型说明符 函数名(参数表) const;`  
const关键字可以用于对重载函数的区分。例如：  
```
void print();
void print() const;
```
通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数：不带const关键字的函数。  
### 5.5.3 常引用
常引用所引用的对象不能被更新。形式如下：  
`const 类型说明符 &引用名;`
对于在函数中无须改变其值得参数，不宜使用普通引用方式传递，因为那会使得对象无法被传入，采用传值方式或传递常引用的方式可避免这一问题。对于大对象来说，传值耗时较多，因此传递常引用为宜。复制构造函数的参数一般也宜采用常引用的传递。  

## 5.6 多文件结构和编译预处理命令
### 5.6.1 C++程序的一般组织结构
决定一个声明放在源文件中还是头文件中的一般原则是，将需要分配空间的定义放在源文件中。  
例如，函数的定义（需要为函数代码分配空间）、命名空间作用域中变量的定义（需要为变量分配空间）等。  
而将不需要分配空间的声明放在头文件中。  
例如，类声明、外部函数的原型声明、外部变量的声明、基本数据类型常量的声明等。  
内联函数比较特殊，由于它的内容需要嵌入到每个调用它的函数之中，所以对于那些需要被多个编译单元调用的内联函数，它们的代码被各个编译单元可见，这些内联函数的定义应当出现在头文件中。  
### 5.6.2 外部变量与外部函数
用extern关键字加以声明。在源文件中可以使用外，还能被其他文件使用，称为外部变量。  
在所有类之外声明的函数（也就是非成员函数），都是具有命名空间作用域的，如果没有特殊说明，这样的函数都可以在不同的编译单元中被调用，只要调用之前进行引用性声明（即声明函数原型）即可。当然，也可以在声明函数原型或定义函数时用extern修饰，其效果与不加修饰的默认状态是一样的。  
通常情况下，变量和函数的定义都放在源文件中，而对外部变量和外部函数的引用性声明则放在头文件中。  
应当将不希望被其他编译单元引用的函数和变量放在匿名的命名空间中。  
### 5.6.3 标准c++类
std包含：  
输入输出类  
容器类与ADT（抽象数据类型）  
存储管理类  
算法  
错误处理  
运行环境支持    

# 第6章 数组、指针、与字符串
## 6.1 数组
```
int a[3] = {1,2,3};
```
细节：当指定的初值个数小于数组大小时，剩下的数组元素会被赋予0值。若定义数组时没有指定任何一个元素的初值，对于静态生存期的数组，每个元素仍然会被赋予0值；但对于动态生存期的数组，每个元素的初值是不确定的。  
**注意：和普通变量作参数不同，使用数组名传递数据时，传递的是地址。**  
细节：把数组作为参数时，一般不指定数组第一维的大小，即使指定，也会被忽略。  

## 6.2 指针
### 6.2.4 指针的赋值
一个数组，可以用它的名称来直接表示它的起始地址。**数组名实际上就是一个不能被赋值的指针，即指针常量。**例如下面语句：  
```
int a[10];
int *ptr=a;
```  
### 6.2.7 指针数组
`pLine[i][j]`与`*pLine[i]+j`等价  
通过数组元素的地址可以输出二维数组的元素，形式如下：`*(*(array+i)+j)`

## 6.6 字符串
1. strcpy: 将一个字符串复制到另一个字符串；
2. strcmp: 按辞典顺序比较两个字符串大小；
3. strcat: 将两个字符串连接起来。


# 第7章 继承与派生
## 7.1 类的继承与派生
### 7.1.2 派生类的定义
一般语法形式：  
```
class Derived: public Base1, private Base2
{
public:
    Derived();
    ~Derived();
};
```
一个派生类，可以同时有多个基类，这种情况称为多继承。  
一个派生类只有一个直接基类的情况，称为单继承。  
### 7.1.3 派生类生成过程
派生新类这个过程，经历了3个步骤：吸收基类成员、改造基类成员、添加新的成员。

## 7.2 访问控制
### 7.2.1 公有继承
当类的继承方式为公有继承(public)时，基类的公有成员和保护成员的访问属性在派生类中不变，而基类私有成员不可直接访问。
### 7.2.2 私有继承
当类的继承方式为私有继承(private)时，基类的公有成员和保护成员都以私有成员身份出现在派生类中，而基类私有成员在派生类中不可直接访问。
### 7.2.3 保护继承
当类的继承方式为保护继承(protected)时，基类的公有成员和保护成员都以保护成员的身份出现在派生类中，而基类私有成员不可直接访问。

## 7.3 类型的兼容规则
类型兼容规则：需要基类对象的任何地方，都可以使用公有派生类的对象来替代。  
在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。 
例如：    
```
class B {...}
class D: public B {...}
B b1, *pb1;
D d1;
```
包括以下情况：  
1. 派生类的对象可以隐含转换为基类对象；  
`b1=d1`
2. 派生类的对象可以初始化基类的引用；  
`B &rb=d1`  
3. 派生类的指针可以隐含转换为基类的指针。  
`pb1=&d1`  

## 7.4 派生类的构造和析构函数
### 7.4.1 构造函数
```
class Derived: public Base2, public Base1, public Base3
{
public:
    Derived(int a, int b, int c, int d):Base1(a), member2(d), member1(c), Base2(b){}
private:
    Base1 member1;
    Base2 member2;
    Base3 member3;
}
```
先调用基类的构造函数，然后调用内嵌对象的构造函数。  
基类构造函数的调用顺序是按照派生类定义时的顺序，先Base2，再Base1，最后Base3；  
而内嵌对象的构造函数调用顺序是按照成员在类中的声明的顺序，应该先Base1，再Base2，最后Base3.  

### 7.4.2 复制构造函数

### 7.4.3 析构函数
执行次序和构造函数正好完全相反，首先执行析构函数的函数体，然后对派生类新增的类类型的成员函数进行清理，最后对所有从基类继承来的成员进行清理。  

## 7.5 派生类成员的标识与访问
### 7.5.2 虚基类
将共同基类设置为虚基类，这时从不同的路径继承过来的同名数据成员在内存中就只有一个副本，同一个函数名也只有一个映射。
语法形式：  
`class 派生类名: virtual 继承方式 基类名`

### 7.5.3 虚基类及其派生类构造函数
如果虚基类声明有非默认形式的（即带有形参的）构造函数，并且没有声明默认形式的构造函数，事件就比较麻烦了。这时，在整个继承关系中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中列出对虚基类的初始化。

# 第8章 多态性
## 8.1 多态性概述
### 8.1.1 多态的类型
4类：重载多态、强制多态、包含多态、参数多态。

### 8.1.2 多态的实现
从实现角度分：编译时的多态和运行时的多态。

## 8.2 运算符重载
运算符重载是对已有的运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致不同的行为。  
运算符重载实质就是函数重载。  
### 8.2.1 运算符重载的规则
有几种是不能重载的：类属关系运算符“.”、成员指针运算符“.*”、作用域分辨符“::”、和三目运算符“?:”。  
语法形式如下：  
```
返回类型 operator 运算符(形参表)
{
    函数体
}
```
当以非成员函数形式重载运算符时，有时需要访问运算符参数所涉及类的私有成员，这时可以把该函数声明为类的友元函数。  
### 8.2.2 运算符重载为成员函数
对于双面运算符B，oprd1 B oprd2，相当于oprd1.operator B(oprd2)。  
如果是前置单目运算符U，例如“-”等，U oprd，相当于oprd.operator U()。
如果是后置运算符“++”和“--”，oprd++，相当于oprd.operator++(0)。

### 8.2.3 运算符重载为非成员函数
对于双面运算符B，oprd1 B oprd2，相当于operator B(oprd1, oprd2)。
如果是前置单目运算符U，例如“-”等，U oprd，相当于operator U(oprd)。
如果是后置运算符“++”和“--”，oprd++，相当于operator ++(oprd, 0)。

## 8.3 虚函数
### 8.3.1 一般虚函数成员
声明语法是：  
`virtual 函数类型 函数名(形参表);`  
虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候。  
运行过程中的多态需要满足3个条件，第一是类之间满足赋值兼容规则，第二是要声明虚函数，第三是要由成员函数来调用或者是通过指针、引用来访问虚函数。  
如果是使用对象名来访问虚函数，则绑定在编译过程中就可以（静态绑定），而无须在运行过程中进行。  
习惯：虚函数一般不声明为内联函数，因为对虚函数的调用需要动态绑定，而对内联函数的处理是静态的，所以虚函数一般不能以内联函数处理。但将虚函数声明为内联函数也不会引起错误。  
习惯：派生类覆盖基类的成员函数时，既可以使用`virtual`关键字，也可以不使用，二者没有差别。很多人习惯于派生类的函数中也使用virtual关键字，因为这样可以清楚地提示这是一个虚函数。  

### 8.3.2 虚析构函数
C++中，不能声明虚构造函数，但是可以声明虚析构函数。

## 8.4 纯虚函数与抽象类
### 8.4.1 纯虚函数
声明格式为： 
`virtual 函数类型 函数名(参数表)=0;`  
声明为纯虚函数之后，基类中就不再给出函数的实现部分。

### 8.4.2 抽象类
抽象类无法实例化，只能通过继承机制，生成抽象类的非抽象派生类，然后再实例化。  
抽象类是带有纯虚函数的类。

# 第9章 群体类和群体数据的组织
## 9.1 函数模板与类模板
### 9.1.1 函数模板
定义形式：  
```
template<模板参数表>
类型名 函数名(参数表)
{
    函数体的定义
}
```
例如：  
```
template<typename T>
T abs(T x){
    return x<0?-x:x;
}
```

# 第10章 泛型程序设计与C++标准模板库
## 10.1 泛型程序设计及STL的结构
### 10.1.2 STL简介
#### 容器（container）
1. 向量 vector  
2. 双端队列 deque  
3. 列表 list  
4. 集合 set  
5. 多重集合 multiset  
6. 映射 map  
7. 多重映射 multimap  
顺序容器：vector、deque、list  
关联容器：set、multiset、map、multimap    

#### 迭代器（iterator）
s.begin()、s.end()以及ostream_iterator<int>(cout, "")都是迭代器  

#### 函数对象（function object）
negate<int>()就是一个函数对象  

#### 算法（algorithm）
STL包含了70多种算法  

## 10.3 容器
### 10.3.1 容器的基本功能与分类
基本功能如下：  
```
S s1
s1 op s2  //op可以是==,!=,<,<=,>,>=之一
s1.begin()
s1.end()
s1.clear()
s1.empty()
s1.size()
s1.swap(s2)
```  
```
S::iterator         //普通迭代器类型
S::const_iterator   //常迭代器类型
```  
```
s1.rbegin()                //指向容器的最后一个元素的逆向迭代器
s1.rend()                  //指向容器前一个元素的前一个位置的逆向迭代器
S::reverse_iterator
S::const_reverse_iterator
```  
