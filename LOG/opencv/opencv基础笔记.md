# 第一章 core 模块. 核心功能
## 1.1 Mat - 基本图像容器
### Mat
基本上讲 Mat 是一个类，由两个数据部分组成：矩阵头（包含矩阵尺寸，存储方法，存储地址等信息）和一个指向存储所有像素值的矩阵（根据所选存储方法的不同矩阵可以是不同的维数）的指针。  
矩阵头的尺寸是常数值，但矩阵本身的尺寸会依图像的不同而不同，通常比矩阵头的尺寸大数个数量级。因此，当在程序中传递图像并创建拷贝时，大的开销是由矩阵造成的，而不是信息头。  
OpenCV是一个图像处理库，囊括了大量的图像处理函数，为了解决问题通常要使用库中的多个函数，因此在函数中传递图像是家常便饭。同时不要忘了我们正在讨论的是计算量很大的图像处理算法，因此，除非万不得已，我们不应该拷贝大的图像，因为这会降低程序速度。  
```
Mat A, C;                                 // 只创建信息头部分
A = imread(argv[1], CV_LOAD_IMAGE_COLOR); // 这里为矩阵开辟内存
Mat B(A);                                 // 使用拷贝构造函数
C = A;                                    // 赋值运算符
```  

你可以创建只引用部分数据的信息头。比如想要创建一个感兴趣区域（ ROI ），你只需要创建包含边界信息的信息头:  
```
Mat D (A, Rect(10, 10, 100, 100) ); // using a rectangle
Mat E = A(Range:all(), Range(1,3)); // using row and column boundaries
```  

如果矩阵属于多个 Mat 对象，那么当不再需要它时谁来负责清理？简单的回答是：最后一个使用它的对象。通过引用计数机制来实现。无论什么时候有人拷贝了一个 Mat 对象的信息头，都会增加矩阵的引用次数；反之当一个头被释放之后，这个计数被减一；当计数值为零，矩阵会被清理。  
但某些时候你仍会想拷贝矩阵本身(不只是信息头和矩阵指针)，这时可以使用函数 clone() 或者 copyTo() 。
```
Mat F = A.clone();
Mat G;
A.copyTo(G);
```

现在改变 F 或者 G 就不会影响 Mat 信息头所指向的矩阵。总结一下:  
1. OpenCV函数中输出图像的内存分配是自动完成的（如果不特别指定的话）。  
2. 使用OpenCV的C++接口时不需要考虑内存释放问题。  
3. 赋值运算符和拷贝构造函数（ ctor ）只拷贝信息头。   
4. 使用函数 clone() 或者 copyTo() 来拷贝一副图像的矩阵。  

### 存储方法
1. RGB是最常见的，这是因为人眼采用相似的工作机制，它也被显示设备所采用。  
2. HSV和HLS把颜色分解成色调、饱和度和亮度/明度。这是描述颜色更自然的方式，比如可以通过抛弃最后一个元素，使算法对输入图像的光照条件不敏感。  
3. YCrCb在JPEG图像格式中广泛使用。  
4. CIE L*a*b*是一种在感知上均匀的颜色空间，它适合用来度量两个颜色之间的距离。  

## 1.2 OpenCV如何扫描图像、利用查找表和计时


